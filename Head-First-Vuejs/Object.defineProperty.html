<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Javascript中对象变化侦查</title>
  </head>
  <body>
    <p>在getter中收集依赖，在setter中触发依赖。</p>
    <script>
      class Dep {
        constructor() {
          this.subs = []
        }

        addSub(sub) {
          this.subs.push(sub)
        }

        removeSub(sub) {
          if (this.subs.length > 0) {
            let index = this.subs.indexOf(sub)
            if (index > -1) {
              this.subs = this.subs.splice(index, 1)
            }
          }
        }

        depend() {
          if (window.target) {
            this.addSub(window.target)
          }
        }

        notify() {
          // 浅拷贝一个新数组
          const subs = this.subs.slice()
          subs.forEach(v => {
            v.update()
          })
        }
      }

      // 获取 data.a.b.c 的最后一个对象 data.a.b.c
      function parsePath(path) {
        let bailRE = /[^\w.$]/
        if (bailRE.test(path)) {
          return
        }

        let segments = path.split('.')
        return obj => {
          for (let i = 0; i < segments.length; i++) {
            if (!obj) return
            obj = obj[segments[i]]
          }

          return obj
        }
      }

      class Watcher {
        constructor(vm, expOrFun, cb) {
          this.vm = vm
          // 获取data.a.b.c 最后一层对象
          this.getter = parsePath(expOrFun)
          this.cb = cb
          this.value = this.get()
        }

        get() {
          // 先把自己设置到全局指定的位置
          window.target = this
          // 然后读取数据 因为读取了数据 所以会触发这个数据的getter
          let value = this.getter.call(this.vm, this.vm)
          window.target = undefined
          return value
        }

        update() {
          const oldValue = this.value
          this.value = this.get()
          this.cb.call(this.vm, this.value, this.oldValue)
        }
      }

      class Observer {
        constructor(value) {
          this.value = value

          if (!Array.isArray(value)) {
            this.walk(value)
          }
        }

        walk(obj) {
          let keys = Object.keys(obj)
          keys.forEach(key => {
            defineReactive(obj, key, obj[key])
          })
        }
      }

      function defineReactive(obj, key, val) {
        if (typeof obj === 'object') {
          new Observer(obj)
        }

        let dep = new Dep()

        Object.defineProperty(obj, key, {
          enumerable: true,
          configurable: true,
          get() {
            dep.depend()
            return val
          },
          set(newValue) {
            if (newValue === val) {
              return newValue
            }
            val = newValue
            dep.notify()
          },
        })
      }
    </script>
    <script>
      // 依赖类
    </script>
  </body>
</html>
